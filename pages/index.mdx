# La Wallet Documentation

## What is _La Wallet_ ?

An open source crypto wallet that provides ([BoltCard](https://www.boltcard.org)-compatible) [NTAG 424 DNA](https://www.nxp.com/products/rfid-nfc/nfc-hf/ntag-for-tags-and-labels/ntag-424-dna-424-dna-tagtamper-advanced-security-and-privacy-for-trusted-iot-applications:NTAG424DNA) card functionality.
This documentation will be centered around the constituent backend components:

- System Architecture
- Identity Provider
- Wallet Provider
  - Internal Modules

No specific prior knowledge is assumed, but an acquaintance with general software development and analysis practices is assumed.
Furthermore, programming knowledge should suffice to develop all of the La Wallet components from their descriptions herein.

## System Architecture

In a nutshell, the La Wallet System Architecture consists of two main components:

- the Identity Provider
- the Wallet Provider

The Identity provider is presented as a stand-alone component further down.
The Wallet provider is itself a [NOSTR](https://nostr.com)-connected set of inter-cooperating Internal Modules.

Graphically, the System Architecture looks like this:

![System Architecture](assets/system-architecture.png)

The internal components are:

- **API Gateway:** this is the main generic interface with the outside world.
    The API Gateway is in charge of basic authentication, rate limiting, pacing, etc., and it's also the one responsible for routing the given REST request to the module handling it (or to the Local NOSTR Relay, if applicable).
- **Local NOSTR Relay:** this is the backbone of the internal communication framework, **EVERY STATE-CHANGING MESSAGE SHOULD BE RUN THROUGH THE LOCAL NOSTR RELAY**, this is so that messages in the relay may be published to a _public_ relay for auditing.
- **Internal Modules:** these are the interconnected pieces doing the actual work.
    Examples of actual internal modules are: Ledger Module, EVM-Gateway Module, NFC Card Module, etc.

The arrows represent different API accesses to the Wallet Provider System.
These can be categorized thusly:

- **HTTP APIs:** these are accessed via HTTP, and can be further categorized into:
  - **Ad-Hoc APIs:** an HTTP API hosted and routed directly towards an Internal Module, not necessarily REST-full itself; these APIs are provided for in order to allow for pre-existing use-case-specific behavior.
  - **Generic REST APIs:** a REST API aimed at talking to the system as a whole, used mainly for configuration and API management itself.
- **NOSTR APIs:** these are the main backbone of the Wallet Provider proper; they can be divided into "external" or "internal" ones:
  - **External:** these APIs are not _restricted_ to being externally called (ie. they _can_ be used by Internal Modules to communicate with each other), but _are_ exposed to the outside world nonetheless.
      The entities being transferred back and forth in these APIs are NOSTR events proper; sometimes this will be via a NOSTR-specific mechanism, sometimes it will be via HTTP, and this depends on the access pattern expected of it:
    - **Synchronous Write API:** this is REST API implementing a _synchronous_ NOSTR API provided for low-latency scenarios.
        This API will accept a `PUT` method with a NOSTR event as body, and (based off of the first `p` tag) route it to the corresponding Internal Module, waiting for a response, and sending it back to the client.
    - **Asynchronous Write API:** this is a REST API implementing an _asynchronous_ NOSTR API provided for general use.
        This API will accept a `PUT` method with a NOSTR event as body, and publish it to the Local NOSTR Relay, returning a `200` response to the client.
    - **Asynchronous Read API:** this is simply a WebSocket connection to the Local NOSTR Relay, issued one or more `REQ` NOSTR commands.
  - **Internal:** these APIs are realized via the Local NOSTR Relay proper, and consist more of a set of "protocols" than an API like the ones we're used to.
    - **Asynchronous Read/Write API:** a normal `PUB` / `REQ` pair will serve as the "upstream" (ie. `PUB`) and "downstream" (ie. `REQ`) halves of the communication channel.

The API Gateway component itself provides the implementation for:

- **NOSTR Synchronous Write API:** via a `dispatch` endpoint, where a `PUT` method with a NOSTR event as body will be accepted, examined, and (based off of the first `p` tag therein) routed to the corresponding Internal Module, upon receiving a response it is forwarded to the requesting client as-is.
- **NOSTR Asynchronous Write API:** via a `publish` endpoint, where a `PUT` method with a NOSTR event as body will be accepted, examined, and `PUB`'d to the Local NOSTR Relay.

### Local NOSTR Relay Architecture

The Local NOSTR Relay serves a dual purpose:

1. on the one hand, it makes interacting between cooperating modules extremely simple and uniform,
2. on the other, it allows for all the messages posted therein to be later (or parallelly) published ot external NOSTR relays for auditing.

Internally, the Local NOSTR Relay is implemented thusly:

![Local NOSTR Relay Architecture](assets/nostr-architecture.png)

where:

- **Local NOSTR Relay:** is the local NOSTR relay where NOSTR events are published.
- **Read NOSTR Replica:** these are clusters of NOSTR relays that serve as read-only replicas.
- **C:** the externally-subscribed clients.

Note how this keeps the load on the write-relay relatively low, requiring only as many `REQ` subscriptions as are established by the Internal Modules, and as many replication streams as there are read-only replicas.

The image above shows a simple, single-level replication structure, one could just as easily cascade read-only replicas in a tree structure so as to keep outgoing channels to a minimum in each specific relay; we judge that to only complicate exposition in this case, but large-scale implementations may very well require this.

### Internal Module (Generic) Architecture

An Internal Module's generic architecture looks like this:

![Internal Module Architecture](assets/module-architecture.png)

Its constituent parts are:

- **NOSTR _(optional)_ :** the main asynchronous NOSTR interface via which to publish and subscribe to the main NOSTR backbone.
- **Synchronous Nostr _(optional)_ :** a synchronous REST API that accepts a NOSTR event and synchronously acts upon it.
- **Ad-Hoc REST API _(optional)_ :** a set of _ad-hoc_ REST API endpoints to support non-NOSTR-based flows.
- **Internal NOSTR Relay _(optional)_ :** an optional part of the Internal Module's architecture, its purpose is to act as a sort of "local read-only replica", so as to reduce the pressure on the main Local NOSTR Relay whilst at the same time providing all the required `REQ` subscriptions to the module's Business Logic.
- **Resources _(optional)_ :** an Internal Module is free to declare and use as many resources as it sees fit, they're their sole responsibility and the System Architecture at large knows not about them.
- **Business Logic:** the Internal Module's business logic component realizes the module's purpose (it may contain an internal router, expose different sets of ports for different APIs, whatever the Internal Module's writer desires, so long as the API Gateway knows how to interact with it).

**ALL** Internal Modules are required to answer to (at least) one NOSTR Public Key.
Furthermore, the API Gateway needs to know how to route HTTP requests to the appropriate internal module.

In what follows, we'll assume that _all_ Internal Modules implicitly know the public keys every other internal module responds to; furthermore, we'll assume _all_ internal modules implicitly know how to route HTTP requests to the appropriate internal modules.

## NOSTR Event Anatomy

The expected form of _all_ NOSTR events transferred from, to, and within the wallet provider is as follows (re. [NIP-01: Basic Protocol Flow Description](https://github.com/nostr-protocol/nips/blob/master/01.md)):

```json
{
  "id": "{32-bytes lowercase hex-encoded event ID}",
  "pubkey": "{32-bytes lowercase hex-encoded public key of the event's SIGNER}",
  "created_at": {UNIX timestamp in seconds},
  "kind": 11111,
  "tags": [
    [
      "k",
      "{event sub-kind}"
    ],
    [
      "p",
      "{32-bytes lowercase hex-encoded public key of the event's TARGET}"
    ],
    "{additional 'p' tags may follow}",
    [
      "alt",
      "{human-readable description of the event}"
    ],
    [
      "delegation",
      "{32-bytes lowercase hex-encoded public key of the event's AUTHOR}",
      "{conditions query string: 'kind=11111&created_at>{UNIX timestamp lower limit in seconds}&created_at<{UNIX timestamp upper limit in seconds}'}",
      "{delegation token: 64-byte lowercase hex-encoded Schnorr signature of the SHA256 hash of 'nostr:delegation:{value of the .pubkey field}:{conditions query string}' using the AUTHOR's secret key}"
    ],
    "{additional tags may follow}"
  ],
  "content": "{stringified JSON content}",
  "sig": "{64-byte lowercase hex-encoded Schnorr signature of the event's .id field using the SIGNER's secret key}"
}
```

The `.created_at` timestamp **MUST** be within 2 seconds of the Local NOSTR Relay's current timestamp (cf. [NIP-22: Event `created_at` Limits](https://github.com/nostr-protocol/nips/blob/master/22.md)).

The `"k"` tag marks _what_ specific event sub-kind this event refers to.
Note how a single `.kind` is reserved, multiplexing sub-kinds based off of the value of the `"k"` tag.
The actual value of the `"k"` tag need not be an "integer string" and may instead be an arbitrary string (hopefully bearing some mnemonic meaning itself).
This tag is **REQUIRED** and **MUST NOT** be repeated.

At least one `"p"` tag **MUST** be provided, and these tags **SHOULD NOT** be repeated.

The `"alt"` tag is prescribed in accordance to [NIP-31: Dealing with Unknown Event Kinds](https://github.com/nostr-protocol/nips/blob/master/31.md).
This tag is **OPTIONAL** and **MUST NOT** be repeated.

The `"delegation"` tag follows the guidelines exposed in [NIP-26: Delegated Event Signing](https://github.com/nostr-protocol/nips/blob/master/26.md).
This tag is **OPTIONAL** and **MUST NOT** be repeated.

The `.content` field **MUST** be a (properly escaped) stringified JSON object itself.

### Event's `AUTHOR`, `SIGNER`, and `TARGET`s

A NOSTR event is expected to define three related entities:

- **The event's `SIGNER`:** is the entity actually signing the NOSTR event proper, filling in the `.pubkey` and `.signature` fields.
- **The event's `AUTHOR`:** is the entity _on behalf of whom_ the NOSTR event is being created, found on index `1` of the `"delegation"` tag's content.
  If there's no `"delegation"` tag, then the event's `AUTHOR` is the event's `SIGNER`.
- **The event's `TARGET`s:** are the entities to which the NOSTR event should be routed, these are found on index `1`of each `"p"` tag.

In what follows we'll simply refer to an event's `AUTHOR`, `SIGNER`, and `TARGET`s as defined above, and refrain from referring to specific event fields or tag values or indices.

## API Gateway (NOSTR Endpoints)

The API Gateway exposes two endpoints intended to interact with the Local NOSTR Relay.

- **`{base API url}/nostr/dispatch`:** the synchronous NOSTR API endpoint.
- **`{base API url}/nostr/publish`:** the asynchronous NOSTR API endpoint.

Both endpoints accept an `OPTIONS` request method with the following response:

```http
HTTP/1.1 204 No Content
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
Allow: OPTIONS, POST
{additional headers may be present}
```

Upon being requested any method other than `OPTIONS` or `POST`, these endpoints respond with:

```http
HTTP/1.1 405 Method Not Allowed
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
Allow: OPTIONS, POST
{additional headers may be present}
```

Both endpoints expect the body to consist of a NOSTR event JSON, if the content cannot be parsed as a valid JSON object, these endpoints respond with:

```http
HTTP/1.1 415 Unsupported Media Type
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
{additional headers may be present}
```

If the request contained an `Accept` header, and said header indicated a media type other than `application/json` or (preferably) `application/nostr+json`, these endpoints respond with:

```http
HTTP/1.1 406 Not Acceptable
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
{additional headers may be present}

application/json
```

If the request's body _can_ be parsed as a JSON object, but this object does not conform to the NOSTR protocol specification, these endpoints respond with:

```http
HTTP/1.1 422 Unprocessable Content
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
{additional headers may be present}
```

The potential offenses include (but are not limited to):

- missing first-level field: all of the basic NOSTR fields are **REQUIRED** (ie. `.id`, `.pubkey`, `.created_at`, `.kind`, `.tags`, `.content`, and `.sig`),
- malformed field values: malformed `.id`, `.pubkey`, `created_at`, or `.sig` fields; additionally, malformed `.tags` contents:
  - a single `"k"` tag is required,
  - at least one `"p"` tag is required; additionally, it should not be malformed,
  - at most one `"delegation"` tag is required; additionally:
    - it should not be malformed,
    - it should validate cryptographically, and
    - the conditions query string should match the actual event, and
  - at most one `"alt"` tag is required
- malformed `.content` field

Upon successfully parsing and validating the request body, the asynchronous NOSTR API endpoint (ie. `{base API url}/nostr/publish`) will send an `EVENT` message to the Local NOSTR Relay (via WebSockets) with the request body as data and respond with:

```http
HTTP/1.1 202 Accepted
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
Location: nostr:{nevent}
Content-Length: 0
{additional headers may be present}
```

Where the `nostr:{nevent}` value of the `Location` header conforms to [NIP-21: `nostr:` URI Scheme](https://github.com/nostr-protocol/nips/blob/master/21.md) pointing to the event id in the request body.

On the other hand, upon successfully parsing and validating the request body, the synchronous NOSTR API endpoint (ie. `{base API url}/nostr/dispatch`) will apply one more validation:

- there should be **EXACTLY ONE** `"p"` tag within the `.tags` field.

If this validation fails, the endpoint rill respond with:

```http
HTTP/1.1 422 Unprocessable Content
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
{additional headers may be present}
```

Otherwise, the API Gateway will query its internal routing table for the given `"p"` tag value, if no routing information is found, the endpoint responds with:

```http
HTTP/1.1 421 Misdirected Request
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
{additional headers may be present}
```

Finally, if the additional validation succeeded, and routing information is found for the single `"p"` tag value, the API Gateway will forward the request as-is to the corresponding internal module, and respond with:

```http
HTTP/1.1 200 OK
Date: {day name}, {day} {month} {year} {hour}:{minute}:{second} GMT
{additional headers may be present}

{upstream response body}
```

> **NOTE:** the API Gateway will respond successfully, even when the downstream server may respond with an error code.
> This apparent inconsistency can be easily explained: the API Gateway was indeed able to process the provided entity and route it, it just so happens that the routed entity raised an error in the downstream server.
> Thus, "semantic" errors are dealt with as NOSTR events, returned by the downstream servers.
